/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => AccentColorPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  sourceColor: "",
  livePreviewColor: "",
  readingColor: "",
  darkSourceColor: "",
  darkLivePreviewColor: "",
  darkReadingColor: ""
};
var DEFAULT_HSL = [250, 100, 50];
var SETTING_KEYS = {
  sourceColor: "sourceColor",
  livePreviewColor: "livePreviewColor",
  readingColor: "readingColor",
  darkSourceColor: "darkSourceColor",
  darkLivePreviewColor: "darkLivePreviewColor",
  darkReadingColor: "darkReadingColor"
};
var AccentColorPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new AccentColorSettingTab(this.app, this));
    this.registerEvent(this.app.workspace.on("active-leaf-change", () => this.updateAccentColor()));
    this.registerEvent(this.app.workspace.on("layout-change", () => this.updateAccentColor()));
    this.registerEvent(this.app.workspace.on("css-change", () => this.updateAccentColor()));
    this.updateAccentColor();
  }
  async loadSettings() {
    const data = await this.loadData();
    if (data) {
      this.settings = {
        sourceColor: data.sourceColor || DEFAULT_SETTINGS.sourceColor,
        livePreviewColor: data.livePreviewColor || DEFAULT_SETTINGS.livePreviewColor,
        readingColor: data.readingColor || DEFAULT_SETTINGS.readingColor,
        darkSourceColor: data.darkSourceColor || DEFAULT_SETTINGS.darkSourceColor,
        darkLivePreviewColor: data.darkLivePreviewColor || DEFAULT_SETTINGS.darkLivePreviewColor,
        darkReadingColor: data.darkReadingColor || DEFAULT_SETTINGS.darkReadingColor
      };
    } else {
      this.settings = { ...DEFAULT_SETTINGS };
    }
    if (!data) {
      await this.saveData(this.settings);
    }
  }
  async saveSettings() {
    const cleanSettings = {
      [SETTING_KEYS.sourceColor]: this.settings.sourceColor,
      [SETTING_KEYS.livePreviewColor]: this.settings.livePreviewColor,
      [SETTING_KEYS.readingColor]: this.settings.readingColor,
      [SETTING_KEYS.darkSourceColor]: this.settings.darkSourceColor,
      [SETTING_KEYS.darkLivePreviewColor]: this.settings.darkLivePreviewColor,
      [SETTING_KEYS.darkReadingColor]: this.settings.darkReadingColor
    };
    await this.saveData(cleanSettings);
    this.updateAccentColor();
  }
  isDarkMode() {
    return document.body.classList.contains("theme-dark");
  }
  updateAccentColor() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (!activeView)
      return;
    const mode = this.detectMode(activeView);
    const isDark = this.isDarkMode();
    let color;
    if (isDark) {
      if (mode === "livePreview") {
        color = this.settings.darkLivePreviewColor || this.settings.livePreviewColor || "";
      } else if (mode === "source") {
        color = this.settings.darkSourceColor || this.settings.sourceColor || "";
      } else {
        color = this.settings.darkReadingColor || this.settings.readingColor || "";
      }
    } else {
      if (mode === "livePreview") {
        color = this.settings.livePreviewColor || "";
      } else if (mode === "source") {
        color = this.settings.sourceColor || "";
      } else {
        color = this.settings.readingColor || "";
      }
    }
    if (!color.trim()) {
      const [h, s, l] = DEFAULT_HSL;
      document.body.style.setProperty("--accent-h", h.toString());
      document.body.style.setProperty("--accent-s", s + "%");
      document.body.style.setProperty("--accent-l", l + "%");
      return;
    }
    if (!color.startsWith("#")) {
      color = "#" + color;
    }
    try {
      const [h, s, l] = this.convertToHSL(color);
      document.body.style.setProperty("--accent-h", h.toString());
      document.body.style.setProperty("--accent-s", s + "%");
      document.body.style.setProperty("--accent-l", l + "%");
    } catch (e) {
      const [h, s, l] = DEFAULT_HSL;
      document.body.style.setProperty("--accent-h", h.toString());
      document.body.style.setProperty("--accent-s", s + "%");
      document.body.style.setProperty("--accent-l", l + "%");
    }
  }
  detectMode(view) {
    const sourceView = view.contentEl.querySelector(".markdown-source-view");
    const readingView = view.contentEl.querySelector(".markdown-reading-view");
    if (readingView && window.getComputedStyle(readingView).display !== "none") {
      return "reading";
    } else if (sourceView) {
      return sourceView.classList.contains("is-live-preview") ? "livePreview" : "source";
    }
    return "source";
  }
  convertToHSL(color) {
    var _a;
    if (!color.trim()) {
      return DEFAULT_HSL;
    }
    const temp = document.createElement("div");
    temp.style.color = color;
    document.body.appendChild(temp);
    const computedColor = getComputedStyle(temp).color;
    document.body.removeChild(temp);
    if (computedColor === "rgb(0, 0, 0)" && !color.match(/black|#000|rgb\(0,\s*0,\s*0\)/i)) {
      return DEFAULT_HSL;
    }
    const rgb = (_a = computedColor.match(/\d+/g)) == null ? void 0 : _a.map(Number);
    if (!rgb || rgb.length !== 3) {
      return DEFAULT_HSL;
    }
    const [r, g, b] = rgb.map((v) => v / 255);
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;
    if (max === min) {
      h = s = 0;
    } else {
      const d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      switch (max) {
        case r:
          h = (g - b) / d + (g < b ? 6 : 0);
          break;
        case g:
          h = (b - r) / d + 2;
          break;
        case b:
          h = (r - g) / d + 4;
          break;
        default:
          h = 0;
      }
      h /= 6;
    }
    return [Math.round(h * 360), Math.round(s * 100), Math.round(l * 100)];
  }
};
var AccentColorSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Light Mode Colors" });
    this.addColorSettings(containerEl, false);
    containerEl.createEl("h2", { text: "Dark Mode Colors" });
    this.addColorSettings(containerEl, true);
  }
  addColorSettings(container, isDark) {
    const modes = ["source", "livePreview", "reading"];
    modes.forEach((mode) => {
      const settingKey = isDark ? `dark${mode.charAt(0).toUpperCase() + mode.slice(1)}Color` : `${mode}Color`;
      new import_obsidian.Setting(container).setName(`${mode.charAt(0).toUpperCase() + mode.slice(1)} Color`).setDesc(isDark ? `Set the accent color for ${mode} mode in dark theme (Leave blank to use light theme color)` : `Set the accent color for ${mode} mode in light theme`).addText((text) => text.setPlaceholder(isDark ? "Enter color or leave blank" : "Enter color").setValue(this.plugin.settings[settingKey]).onChange(async (value) => {
        this.plugin.settings[settingKey] = value;
        await this.plugin.saveSettings();
      }));
    });
  }
};
